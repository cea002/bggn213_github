---
title: "Class 12"
author: "Courtney Anderson (PID:A69038035)"
format: pdf
toc: TRUE
---

## Background

Today we will analyze some RNAseq data from Himes et. al on the effects of a common steroid (dexmethansone also called "dex") on airway smooth muscle cells (ASMs).

For this analysis we need two main inputs:

-`countData`: a table of **counts** per gene (in rows) across expriments (in columns)
-`colData`: **metadata** about the design of experiments. The rows here must mat h the columns in 'countData'

```{r}
library(BiocManager)
library(DESeq2)
```


## Data Import 

```{r}
counts <- read.csv("airway_scaledcounts.csv", row.names=1)
metadata <- read.csv("airway_metadata.csv")
```
```{r}
head(counts)
```
```{r}
head(metadata)
```

>Q1a. How many "genes" are in this dataset?

```{r}
nrow(counts)
```

>Q1b. How many experiments (i.e columns in `counts` or rows in `metadata`) are there

```{r}
ncol(counts)
```
>Q2. How many control experiments are there in the database?

```{r}
sum(metadata$dex== "control")
  
```
## Toy analysis example

>Q3. How would you make the above code in either approach more robust? Is there a function that could help here? I would use the rowMeans() funcition instead of rowSums().

1. Extract the "control" columns from `counts`
```{r}
control.inds <- metadata$dex=="control"
control.counts <- counts[,control.inds]

```

2. Calculate the mean value for each gene in these "control" columns
```{r}
control.mean <- rowMeans(control.counts)
```

>Q4. Follow the same procedure for the treated samples (i.e. calculate the mean per gene across drug treated samples and assign to a labeled vector called treated.mean)

3-4. Co the same for the treated columns 
```{r}
treated.mean <- rowMeans(counts[,metadata$dex=="treated"])
```

5. Compare these mean values for each gene. For ease of book-keeping we can store these together in one data frame called `meancounts`
```{r}
meancounts <- data.frame(control.mean, treated.mean)
head(meancounts)
```

>Q5 (a). Create a scatter plot showing the mean of the treated samples against the mean of the control samples. Your plot should look something like the following.

Plot these against eachother
```{r}
plot(meancounts)
```
>Q5 (b).You could also use the ggplot2 package to make this figure producing the plot below. What geom_?() function would you use for this plot?] I would use geom_point() function. 

This is screaming at me to log it
```{r}
plot(meancounts, log="xy")
```
>Q6. Try plotting both axes on a log scale. What is the argument to plot() that allows you to do this? Log2

We use log2 "fold change" as a way to compare 

```{r}
#treated/control
log2(10/10)
log2(20/10)
log2(10/20)
log2(40/10)
```
```{r}
meancounts$log2fc <- log2(meancounts[,"treated.mean"]/meancounts[,"control.mean"])
head(meancounts)
```
```{r}
zero.vals <- which(meancounts[,1:2]==0, arr.ind=TRUE)

to.rm <- unique(zero.vals[,1])
mycounts <- meancounts[-to.rm,]
head(mycounts)
```

>Q7. What is the purpose of the arr.ind argument in the which() function call above? Why would we then take the first column of the output and need to call the unique() function? 
When arr.ind=TRUE, it will return the row and columns that are TRUE. We would need to take the first column od the output to call it a unique function so we dont count any row twice. 

A common rule of thumb threshold for calling somthing"up" regulated is a log2-fold change of +2 or greater. For down regulated -2 or less.

```{r}
up.ind <- mycounts$log2fc > 2
down.ind <- mycounts$log2fc < (-2)
```

>Q8. Using the up.ind vector above can you determine how many up regulated genes we have at the greater than 2 fc level? 

```{r}
sum(up.ind)
```

>Q9. Using the down.ind vector above can you determine how many down regulated genes we have at the greater than 2 fc level? 

```{r}
sum(down.ind)
```
>Q10. Do you trust these results? Why or why not? No I dont because we haven't investigated any significance. Time to get p-values involved.  


## DESeq analysis 

Let's do this properly DESeq and put some stats behing these numbers. 

```{r, message=FALSE}
library(DESeq2)
citation("DESeq2")
```
 DESEq wants 3 things for analysis, countDATA, colDATA and design
 
```{r}
dds <- DESeqDataSetFromMatrix(countData=counts, 
                              colData=metadata, 
                              design=~dex)
dds
```
 The main fucntion in the DESeq package to run analysis is called `DESeq()`
```{r}
vsd <- vst(dds, blind = FALSE)
plotPCA(vsd, intgroup = c("dex"))
```
 
```{r}
pcaData <- plotPCA(vsd, intgroup=c("dex"), returnData=TRUE)
head(pcaData)
```
```{r}
# Calculate percent variance per PC for the plot axis labels
percentVar <- round(100 * attr(pcaData, "percentVar"))
```

```{r}
library(ggplot2)

ggplot(pcaData) +
  aes(x = PC1, y = PC2, color = dex) +
  geom_point(size =3) +
  xlab(paste0("PC1: ", percentVar[1], "% variance")) +
  ylab(paste0("PC2: ", percentVar[2], "% variance")) +
  coord_fixed() +
  theme_bw()
```

```{r}
dds <- DESeq(dds)
results(dds)
```

```{r}
res <- results(dds)
res
```
```{r}
summary(res)
```
```{r}
res05 <- results(dds, alpha=0.05)
summary(res05)
```
```{r}
library("AnnotationDbi")
library("org.Hs.eg.db")

columns(org.Hs.eg.db)
```
```{r}
res$symbol <- mapIds(org.Hs.eg.db,
                     keys=row.names(res), # Our genenames
                     keytype="ENSEMBL",        # The format of our genenames
                     column="SYMBOL",          # The new format we want to add
                     multiVals="first")
head(res)
```

```{r}
res$entrez <- mapIds(org.Hs.eg.db,
                     keys=row.names(res),
                     column="ENTREZID",
                     keytype="ENSEMBL",
                     multiVals="first")

res$uniprot <- mapIds(org.Hs.eg.db,
                     keys=row.names(res),
                     column="UNIPROT",
                     keytype="ENSEMBL",
                     multiVals="first")

res$genename <- mapIds(org.Hs.eg.db,
                     keys=row.names(res),
                     column="GENENAME",
                     keytype="ENSEMBL",
                     multiVals="first")
res$symbol <-mapIds(org.Hs.eg.db,
                     keys=row.names(res),
                     column="SYMBOL",
                     keytype="ENSEMBL",
                     multiVals="first")

head(res)
```

```{r}
ord <- order( res$padj )
#View(res[ord,])
head(res[ord,])
```

```{r}
write.csv(res[ord,], "deseq_results.csv")
```

```{r}
# Convert DESeq2 results object to a regular data frame
res.df <- as.data.frame(res)
```


## Volcano Plot 

This is a plot of log2FC vs adjusted p-value
```{r}
plot( res$log2FoldChange,  -log(res$padj), 
      xlab="Log2(FoldChange)",
      ylab="-Log(P-value)")
```
```{r}
plot( res$log2FoldChange,  -log(res$padj), 
 ylab="-Log(P-value)", xlab="Log2(FoldChange)")

# Add some cut-off lines
abline(v=c(-2,2), col="darkgray", lty=2)
abline(h=-log(0.05), col="darkgray", lty=2)
```
```{r}
# Setup our custom point color vector 
mycols <- rep("gray", nrow(res))
mycols[ abs(res$log2FoldChange) > 2 ]  <- "red" 

inds <- (res$padj < 0.01) & (abs(res$log2FoldChange) > 2 )
mycols[ inds ] <- "blue"

# Volcano plot with custom colors 
plot( res$log2FoldChange,  -log(res$padj), 
 col=mycols, ylab="-Log(P-value)", xlab="Log2(FoldChange)" )

# Cut-off lines
abline(v=c(-2,2), col="gray", lty=2)
abline(h=-log(0.1), col="gray", lty=2)
```

## A nicer ggplot volcano plot

```{r}
library(ggplot2)

mycols <- rep("gray", nrow(res))
mycols[abs(res$log2FoldChange) >= 2 & res$padj < 0.05] <- "blue"  # significant and large change
mycols[res$padj >= 0.05] <- "gray"  # non-significant (optional, ensures gray)

# Volcano plot
ggplot(res, aes(x = log2FoldChange, y = -log(padj))) +
  geom_point(color = mycols) +
  geom_vline(xintercept = c(-2, 2), color = "black") +
  geom_hline(yintercept = -log(0.05), color = "black") +
  labs(
    x = "log2(Fold Change)",
    y = "-log(Adjusted p-value)",
    title = "Volcano Plot"
  ) +
  theme_minimal()
```
```{r}
colnames(res)
head(res)
```
```{r}
library(EnhancedVolcano)
x <- as.data.frame(res)
head(x)

```

```{r}
#| fig-width: 10
#| fig-height: 8

EnhancedVolcano(
    x,
    lab = res$symbol,                      # gene labels
    x = 'log2FoldChange',                # x-axis: fold change
    y = 'pvalue',                        # y-axis: p-value
    title = 'Differential Expression (Condition A vs B)',
    subtitle = 'DESeq2 results',
    xlab = bquote(~Log[2]~ 'fold change'),
    ylab = bquote(~-Log[10]~italic('p-value')),
    pCutoff = 0.05                       # significance cutoff (no trailing comma!)
)

```


## Pathway Analysis 
```{r}
library(pathview)
library(gage)
library(gageData)

data(kegg.sets.hs)

# Examine the first 2 pathways in this kegg set for humans
head(kegg.sets.hs, 2)
```
```{r}
library(org.Hs.eg.db)
library(AnnotationDbi)

res$entrez <- mapIds(org.Hs.eg.db,
                     keys = rownames(res),    # your Ensembl IDs
                     column = "ENTREZID",
                     keytype = "ENSEMBL",
                     multiVals = "first")
```
```{r}
sum(!is.na(res$entrez))   # should now be most genes
head(res$entrez)

```
```{r}
head(res$entrez)
```
```{r}
foldchanges = res$log2FoldChange
names(foldchanges) = res$entrez
head(foldchanges)
```

```{r}
# Get the results
keggres = gage(foldchanges, gsets=kegg.sets.hs)
attributes(keggres)
```


```{r}
# Look at the first three down (less) pathways
head(keggres$less, 3)
```


```{r}
pathview(gene.data=foldchanges, pathway.id="hsa05310")

```
```{r}
library(png)
library(grid)

# Read the image file (replace 'my_image.png' with your filename)
img <- readPNG("hsa05310.pathview.png")

# Display the image
grid.raster(img)
```



