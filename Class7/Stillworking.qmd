---
title: "Class 7: Machine Learning"
author: "Courtney Anderson (PID:A69038035)"
format: pdf
---

Today, we will begin our exploration of some"classical" means learning approaches. We will start with clustering: 

Lets first make up some data cluster where we know what the answer should be.

```{r}
hist (rnorm(1000))
```

```{r}
x <- c( rnorm(30, mean=3),rnorm(30,mean=-3))
y <- rev(x)

z <- cbind(x,y)
head(z)
plot(z)
```
The main function in "base" R for K-means clustering is called `kmeans()`.
```{r}
k <- kmeans(z,centers = 2)
```

>Q. How big are the clusters?

```{r}
k$size
```
>Q. What clusters fo my data points reside in? 

```{r}
k$cluster
```

>Q. can you make a plot of our data colored by cluster assigment 
i.e. Make a result figure

```{r}
plot(z, col = k$cluster)
points(k$centers, col = "purple", pch = 12)
```
>Q. Cluster with K-means into 4 clusters and plot your results above 

```{r}
k4 <- kmeans(z,centers = 4)
```
```{r}
k4$cluster
```

```{r}
plot(z, col=k4$cluster)
points(k4$centers, col="purple", pch=12)
```

>Run kmeans with centers (i.e. values of k) equal 1 to 6

```{r}
k1 <- kmeans(x,centers=1)$tot.witness
k2 <- kmeans(x,centers=2)$tot.witness
k3 <- kmeans(x,centers=3)$tot.witness
k4 <- kmeans(x,centers=4)$tot.witness
k5 <- kmeans(x,centers=5)$tot.witness
k6 <- kmeans(x,centers=6)$tot.witness

ans <- c(k1, k2, k3, k4, k5, k6)
```

Or use a for loop (Make a scree-plot)
```{r}
ans <- NULL
for(i in 1:6){
  ans <- c(ans, kmeans(x, centers=i)$tot.withinss)
}
ans
plot(ans, typ="b")
```

##Hierarchical Clustering

The main function in "base" R for this is called `hclust()`
```{r}
d <-  dist(x)
hc <- hclust(d)
hc
```

```{r}
plot(hc)
abline(h=7,col=2)
```

To obtain clusters from our `hclust` object **hc** we "cut" the tree into sub branches.  For this we can use the `cutree()` function
```{r}
grps <- cutree(hc, h=7)
grps 
```
Results figure
```{r}
plot(x,col=grps)
```

```{r}
library (pheatmap)
pheatmap(z)
```
## Prinicipal Component Analysis (PCA)

PCA is a dimensional reduction, to take all things measuring and projects them on PC axes.
PC1 is the “best fit” of the data, that maximizes the data spread/variance in data. It captures
the most variance.PC2 captures the rest of the variance. PC looks to see the left/right and
up/down variance easier to see. Think of a big funnel, and putting all your datta in it.

>Q1. How many rows and columns are in your new data frame named x? What R functions could you use to answer this questions?

There are 17 rows and 5 columns. You could use nrow and ncol.

```{r}
x <- read.csv(file = "UK_foods.csv")
```


```{r}
nrow(x)
ncol(x)
```
## Preview the first 6 rows

```{r}
head(x)
```
Fix the row names 

```{r}
rownames(x) <- x[,1]
x <- x[,-1]
head(x)
```


```{r}
dim(x)
```
I fixed the rownames again ( I was having trouble with my file)
```{r}
x <- read.csv("UK_foods.csv", row.names=1)
head(x)
```

>Q2. Which approach to solving the ‘row-names problem’ mentioned above do you prefer and why? Is one approach more robust than another under certain circumstances?

I prefer the second method just because its quicker and requires less typing. (more)

```{r}
barplot(as.matrix(x), beside=T, col=rainbow(nrow(x)))
```

```{r}
barplot(as.matrix(x), beside=F, col=rainbow(nrow(x)))
```

>Q3: Changing what optional argument in the above barplot() function results in
the following plot?

Just change the beside to equal False or F

```{r}
library(tidyr)
x_long <- x |>

tibble::rownames_to_column("Food") |>
pivot_longer(cols = -Food,
names_to = "Country",
values_to = "Consumption")

dim(x_long)
```
```{r}
head(x_long)
```
```{r}
library(ggplot2)
ggplot(x_long) +
aes(Country, Consumption, fill = Food) +
geom_col(position = "dodge") +
theme_bw()
```

>Q4: Changing what optional argument in the above barplot() function results in the following plot?

Change the geom_col(position = “dodge”) to just geom_col().

```{r}
ggplot(x_long) +
aes(Country, Consumption, fill = Food) +
geom_col() +
theme_bw()
```


```{r}
pairs(x, col=rainbow(10), pch=16)
```

>Q5: Generating all pairwise plots may help somewhat. Can you make sense of the following code and resulting figure? What does it mean if a given point lies on the diagonal for a given plot?

The points on the plots are specific types of food. If a point lies on the diagonal then that means that the food level is the same in both countries. If one point lies outside of the diagonal then that means that the food is being consumed at different levels between the two countries.

```{r}
pheatmap( as.matrix(x) )
```

>Q6. What is the main differences between N. Ireland and the other countries of the UK in terms of this data-set?
 
Ireland appears to consume more potatoes than the other countries. They also consume less fresh fruit and other meats compared to other countries. Finally they have high consumption of soft drinks and cereals (but these values are more comparable).

##PCA to the rescue 

> Q7. Complete the code below to generate a plot of PC1 vs PC2. The second line adds text labels over the data points.

The main function in “base” R for PCA is called `prcomp()`. As we want to do PCA on the food data, for the different countries, we will want the foods in the columns.
```{r}
t(x)
```

```{r}
pca <- prcomp( t(x) )
summary(pca)
```
```{r}
pca$x
```


```{r}
library(ggplot2)

ggplot(pca$x) + 
  aes(PC1, PC2, label = rownames(pca$x)) + 
  geom_point() + 
  geom_text()
```

>Q8. Customize your plot so that the colors of the country names match the colors in our UK and Ireland map and table at start of this document.

```{r}
library(ggplot2)

# Example: add a grouping column (one color per region)
regions <- data.frame(
  name = rownames(pca$x),
  region = c("England", "Scotland", "Wales", "N.Ireland")
)

# Combine with PCA results
df <- cbind(pca$x, regions)

# Plot with custom colors
ggplot(df, aes(PC1, PC2, label = name, color = region)) +
  geom_point(alpha=0.2) +
  geom_text() +
  scale_color_manual(values = c(
    "England" = "orange",
    "Scotland" = "blue",
    "Wales" = "red",
    "N.Ireland" = "darkgreen"
  )) +
  theme_bw() +
  labs(x = "PC1", y = "PC2")

```

```{r}
v <- round( pca$sdev^2/sum(pca$sdev^2) * 100 )
v
```

```{r}
z <- summary(pca)
z$importance
```
```{r}
barplot(v, xlab="Principal Component", ylab="Percent Variation")
```

##Digging Deeper(variable loadings)

## Lets focus on PC1 as it accounts for > 90% of variance 

```{r}
par(mar=c(10, 3, 0.35, 0))
barplot( pca$rotation[,1], las=2 )
```

>Q9: Generate a similar ‘loadings plot’ for PC2. What two food groups feature prominantely and what does PC2 maninly tell us about?  

Fresh potatoes and soft drinks are featured prominently. PC2 mainly tells us the secondary differences in the data.

```{r}
par(mar=c(10, 3, 0.35, 0))
barplot( pca$rotation[,2], las=2 )
```

Another major result of PCA is the so-called “variable loadings” or `$rotation` that tells us how the origional variables (foods) contribute to PCs (i.e. our new axis).

```{r}
pk <- pca$rotation
pk
```
```{r}
ggplot(pk) + aes(PC1, rownames(pk)) + geom_col()
```

##Biplots

```{r}
biplot(pca)
```

##PCA or RNA seq data

```{r}
url2 <- "https://tinyurl.com/expression-CSV"
rna.data <- read.csv(url2, row.names=1)
head(rna.data)
```
```{r}
nrow(rna.data)
```
>Q10: How many genes and samples are in this data set?

There are 100 genes.

```{r}
pca <- prcomp(t(rna.data), scale=TRUE)
```

```{r}
plot(pca$x[,1], pca$x[,2])
```
```{r}
pca.var <- pca$sdev^2
```

```{r}
pca.var.per <- round(pca.var/sum(pca.var)*100, 1)
pca.var.per
```

```{r}
barplot(pca.var.per, main="Scree Plot", 
        xlab="Principal Component", ylab="Percent Variation")
```
## A vector of colors for wt and ko samples
```{r}
colvec <- colnames(rna.data)
colvec[grep("wt", colvec)] <- "red"
colvec[grep("ko", colvec)] <- "blue"

plot(pca$x[,1], pca$x[,2], col=colvec, pch=16,
     xlab=paste0("PC1 (", pca.var.per[1], "%)"),
     ylab=paste0("PC2 (", pca.var.per[2], "%)"))

text(pca$x[,1], pca$x[,2], labels = colnames(rna.data), pos=c(rep(4,5), rep(2,5)))
```

## Another way to color by sample type
## Extract the first 2 characters of the sample name
```{r}
sample.type <- substr(colnames(rna.data),1,2)
sample.type
```
## now use this as a factor input to color our plot
```{r}
plot(pca$x[,1], pca$x[,2], col=as.factor(sample.type), pch=16)
```
## Find the top 10 measurements (genes) that contribute
## most to PC1 in either direction (+ or -)
```{r}
loading_scores <- pca$rotation[,1]
gene_scores <- abs(loading_scores) 
gene_score_ranked <- sort(gene_scores, decreasing=TRUE)
```
## Show the top ten genes
```{r}
top_10_genes <- names(gene_score_ranked[1:10])
top_10_genes 
```

